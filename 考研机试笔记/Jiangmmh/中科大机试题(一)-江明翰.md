### 中科大机试题（一）
给定一个数组，找出数组中的最大值、最小值、最大公约数。

#### 1. 最大值最小值的查找
新建一个含两个元素的数组res，遍历数组将最大值放在res[0]，最小值放在res[1]。

#### 2. 所有数组元素的最大公约数

**约数的概念：**
约数，又称因数。整数a除以整数**b(b≠0)** 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。


**两个数的最大公约数**
两个数的约数可能为负数，比如-4和-2的约束可以为-2，但我们求的是最大公约数，其值应该是2，也就是一个正数；因此求这两个数的最大公约数就转化为求这两个数的绝对值的最大公约数。（*注意，这两个数中如果存在一个数为0，那么此二者是没有最大公约数的*）



**求解两个整数的最大公约数的方法：**
- 更相减损术：[百科-更相减损术](https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF/449183?fr=aladdin)
- 辗转相除法：[百科-辗转相除法](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin)

**求解数组中所有整数的最大公约数：**
对前两个元素的绝对值求最大公约数，使用变量g保存，然后求g与第三个元素的绝对值的最大公约数，使用变量tmp保存。比较g与tmp的值，如果g比tmp小，g = tmp。依次类推，直到遍历完数组中所有的元素。
（*优化：如果在遍历中，g的值已经变为1，那么就没有必要继续下去了，因为1已经是最小的公倍数了。*）

#### 3. 代码实现
**查找数组中的最大最小值**
```c++
bool max_min(int* arr, int n, int *res){
	if (n < 1)
		return false;
	if (n < 2){
		res[0] = res[1] = arr[0];
		return true;
	}
	
	int i;
    // 将最大值放在第一个位置，最小值放在第二个位置
	if (arr[0] < arr[1]){
		swap(arr[0], arr[1]);
	}
	
	res[0] = arr[0];
	res[1] = arr[1];
	for (i = 2; i < n; i++){
		if (res[0] < arr[i])
			res[0] = arr[i];
		if (res[1] > arr[i])
			res[1] = arr[i];
	}
	return true;
}
```

**数组的最大公约数**
```c++
int gcd(int a, int b){
	if (a < b)
		swap(a, b);
	
//	辗转相除法
	int r = a % b;
	while (r != 0){
		if (b > r) {
		    a = b;
		    b = r;
		} else {
		    a = r;
		}
		r = a % b;
	}	
    
 //	更相减损术 
//	int r = a - b;
//	
//	while (b != r){
//		
//		if (b > r){
//			a = b;
//			b = r;
//		} else {
//			a = r;
//		}
//		
//		r = a - b;
//	}
	return b;
}


int n_gcd(int *a, int n){
	int g = 0, tmp;
    
	if (a[0] == 0 || a[1] == 0)
		return -1;
		
	g = gcd(abs(a[0]), abs(a[1]));
	for (int i = 2; i < n; i++){
       if (a[i] == 0)
           return -1;
           
		tmp = gcd(abs(a[0]), abs(a[1]));
		
		if (g > tmp)
			g = tmp;
		if (g == 1)
			break;
	}
	return g;
} 
```

**主函数**
```c++
int main(int argc, char** argv) {
	int n;
	
	while (cin >> n){
		int arr[n];
		int res[2];
		for (int i = 0; i < n; i++){
			cin >> arr[i];
		}
		if (max_min(arr, n, res)){
			cout << res[0] << " " << res[1] << " ";
		}
		cout << n_gcd(arr, n) << endl;
	}
	return 0;
}
```